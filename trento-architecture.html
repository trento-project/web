<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="ExDoc v0.29.0">
    <meta name="project" content="Trento Web v1.2.0">

    <title>Trento Architecture — Trento Web v1.2.0</title>
    <link rel="stylesheet" href="dist/html-elixir-2YOS5DIE.css" />

    <script src="dist/handlebars.runtime-NWIB6V2M.js"></script>
    <script src="dist/handlebars.templates-X7YVL3G2.js"></script>
    <script src="dist/sidebar_items-7B49D5E2.js"></script>

      <script src="docs_config.js"></script>

    <script async src="dist/html-XN2TSG4M.js"></script>


  </head>
  <body data-type="extras" class="page-extra">
    <script>

      try {
        var settings = JSON.parse(localStorage.getItem('ex_doc:settings') || '{}');

        if (settings.theme === 'dark' ||
           ((settings.theme === 'system' || settings.theme == null) &&
             window.matchMedia('(prefers-color-scheme: dark)').matches)
           ) {
          document.body.classList.add('dark')
        }
      } catch (error) { }
    </script>

<div class="main">

<button class="sidebar-button sidebar-toggle" aria-label="toggle sidebar">
  <i class="ri-menu-line ri-lg" title="Collapse/expand sidebar"></i>
</button>

<section class="sidebar">
  <form class="sidebar-search" action="search.html">
    <button type="submit" class="search-button" aria-label="Submit Search">
      <i class="ri-search-2-line" aria-hidden="true" title="Submit search"></i>
    </button>
    <button type="button" tabindex="-1" class="search-close-button" aria-label="Cancel Search">
      <i class="ri-close-line ri-lg" aria-hidden="true" title="Cancel search"></i>
    </button>
    <label class="search-label">
      <p class="sr-only">Search</p>
      <input name="q" type="text" class="search-input" placeholder="Search..." aria-label="Input your search terms" autocomplete="off" />
    </label>
  </form>

  <div class="autocomplete">
    <div class="autocomplete-results">
    </div>
  </div>

  <div class="sidebar-header">

      <a href="readme.html">
        <img src="assets/logo.svg" alt="Trento Web" class="sidebar-projectImage">
      </a>

    <div class="sidebar-projectDetails">
      <a href="readme.html" class="sidebar-projectName" translate="no">
Trento Web
      </a>
      <strong class="sidebar-projectVersion" translate="no">
        v1.2.0
      </strong>
    </div>
    <ul class="sidebar-listNav">
      <li><a id="extras-list-link" href="#full-list">GUIDES</a></li>

        <li><a id="modules-list-link" href="#full-list">Modules</a></li>


        <li><a id="tasks-list-link" href="#full-list"><span translate="no">Mix</span> Tasks</a></li>

    </ul>
  </div>

  <div class="gradient"></div>
  <ul id="full-list" class="sidebar-fullList"></ul>
</section>

<section class="content">
  <output role="status" id="toast"></output>
  <div class="content-outer">
    <div id="content" class="content-inner">

<h1>
<button class="settings display-settings">
  <i class="ri-settings-3-line"></i>
  <span class="sr-only">Settings</span>
</button>


    <a href="https://github.com/trento-project/web/blob/main/guides/architecture/trento-architecture.md#L1" title="View Source" class="view-source" rel="help">
      <i class="ri-code-s-slash-line" aria-hidden="true"></i>
      <span class="sr-only">View Source</span>
    </a>

  <span>Trento Architecture</span>
</h1>

<p>Here's a high level view of what we do to achieve the result of providing a reactive event driven system.</p><p><img src="assets/trento-architecture.png" alt="Trento Architecture"/></p><ul><li>Discovery</li><li>Scenario Detection</li><li>Business rules validation</li><li>Events &amp; State change</li><li>State propagation &amp; Reaction</li></ul><h2 id="discovery" class="section-heading">
  <a href="#discovery" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">discovery</p>
  </a>
  Discovery
</h2>
<p>Trento Agent extracts relevant information on the target infrastructure and publishes those to the control plane.<br/><em>(cluster discoveries, host discoveries, cloud discoveries...)</em></p><p>The control plane Discovery integration securely accepts published discoveries, stores them and triggers Scenario Detection.</p><hr class="thin"/><h2 id="scenario-detection" class="section-heading">
  <a href="#scenario-detection" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">scenario-detection</p>
  </a>
  Scenario Detection
</h2>
<p>The control plane discovery integration leverages specific policies to determine the scenario to be triggered based on the discovered information.</p><p>That means we need to be able to determine which command to dispatch in the application.
<em>(RegisterHost, RegisterDatabaseInstance and so forth...)</em></p><hr class="thin"/><h2 id="business-rule-validation" class="section-heading">
  <a href="#business-rule-validation" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">business-rule-validation</p>
  </a>
  Business rule validation
</h2>
<p>The detected scenario dispatches the needed command(s) which trigger validation of the requested action(s) against the current state and the proper business rules for the usecase.</p><hr class="thin"/><h2 id="events-state-change" class="section-heading">
  <a href="#events-state-change" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">events-state-change</p>
  </a>
  Events &amp; State change
</h2>
<p>Going through the previous steps of dispatching and action in the system and applying business rules to the process, translates in things actually happening (or not) and changing some state (or not).</p><p>When things happen we represent them as <strong>events</strong>  (<em>SAPSystemHealthChanged, ChecksExecutioncompleted</em>), we store them in an append only <strong>Event Store</strong> and use them as the source of truth of the system (or part of it).</p><p>See Event Sourcing <a href="https://martinfowler.com/eaaDev/EventSourcing.html">here</a></p><hr class="thin"/><h2 id="state-propagation-reaction" class="section-heading">
  <a href="#state-propagation-reaction" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">state-propagation-reaction</p>
  </a>
  State Propagation &amp; Reaction
</h2>
<p>Once things happen the system notifies the world about it by emitting the recorded events so that interested components can listen for those and react accordingly.</p><p>Reaction may be any orthogonal listener responsible to deliver part of the feature being served.</p><p>Some of possible <em>reactions</em></p><ul><li>projecting read optimized models for specific usecases (<em>Clusters, Hosts, Heartbeats</em>) maybe later served via APIs</li><li>Sending and email <em>whenever a SAP System's health goes critical</em></li><li>Broadcasting changes to the Reactive UI via websockets</li><li>Third party software integration</li><li>...</li></ul><hr class="thin"/><h2 id="not-only-discovery" class="section-heading">
  <a href="#not-only-discovery" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">not-only-discovery</p>
  </a>
  Not only discovery
</h2>
<p>Notice how this document started with <strong>Discovery</strong> triggering actions and subsequent events in the system.</p><p>That's not the only case indeed.</p><p>The user can trigger actions via the Reactive web UI and so the <em>Scenario-Business Rules-Events-Reaction</em> flow is the same, clearly without the Discovery.
Actions (or commands) may also be triggered via API integration, cli integration, Messaging or any other means.</p><p>This is possible thanks to an <a href="https://en.wikipedia.org/wiki/Hexagonal_architecture_(software)">hexagonal</a> approach to the architecture.</p><hr class="thin"/><h2 id="bonus-point" class="section-heading">
  <a href="#bonus-point" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">bonus-point</p>
  </a>
  Bonus point
</h2>
<p>We referred to Event Sourcing and you may have noticed some parallelisms with <a href="https://www.martinfowler.com/bliki/CQRS.html">CQRS</a>.</p><p>That's it. </p><p>We approached architecture and development with <strong>Agile</strong> mindset and <strong>Domain Driven Design</strong> approach to properly understand the problem space and provide good solutions by leveraging <strong>ES</strong>, <strong>CQRS</strong> and <strong>Reactivity</strong>.</p><p>In order to <strong>avoid accidental complexity</strong> we don't use ES+CQRS <em>everywhere by default</em>.
Whenever possible we use simpler implementations for non-critical aspects. (<em>Tagging</em> for instance, is a basic CRUD operation)</p><p>There's a lot of literature out there, here's just a perspective of the thing.</p><p><img src="assets/event-sourcing-cqrs.png" alt="ES+CQRS"/></p>
<div class="bottom-actions">
  <div class="bottom-actions-item">

      <a href="alerting.html" class="bottom-actions-button" rel="prev">
        <span class="subheader">
          ← Previous Page
        </span>
        <span class="title">
Alerting
        </span>
      </a>

  </div>
  <div class="bottom-actions-item">

      <a href="contributing.html" class="bottom-actions-button" rel="next">
        <span class="subheader">
          Next Page →
        </span>
        <span class="title">
How to contribute
        </span>
      </a>

  </div>
</div>
      <footer class="footer">

        <p>
          Built using
          <a href="https://github.com/elixir-lang/ex_doc" title="ExDoc" target="_blank" rel="help noopener" translate="no">ExDoc</a> (v0.29.0) for the

            <a href="https://elixir-lang.org" title="Elixir" target="_blank" translate="no">Elixir programming language</a>

        </p>
      </footer>
    </div>
  </div>
</section>
</div>


  </body>
</html>
